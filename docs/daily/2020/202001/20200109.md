## 概要

1. AMCL

---

## 疑問点


---

## AMCL

地図データ、センサデータ、オドメトリからロボットの自己位置推定を行うパッケージである  
パーティクルフィルタを用いて２次元平面でロボットのx,y座標、yaw角の推定を行う  
パーティクル数は推定の精度によって動的に変動する  
LiDARの観測モデルに従って尤度を更新する？  

### MCL

Monte Carlo Localization(モンテカルロ位置推定)
1. ランダムパーティクルの配置
2. 重み更新
3. 移動によるパーティクルのリサンプリング
4. 重み更新

### Augmented MCL

誘拐からの回復、位置推定からの誤り  
残ったパーティクルが間違えている場合回復できない  
パーティクル数が少ない場合や大きな領域に広がっている場合など  
ランダムなパーティクルを加える  

* 1回のアルゴリズムの繰り返しで何個のパーティクルを加えるか？
    * センサ計測値の確率を監視し、ある時間での確率の平均値を比較する  
    * 短期間の平均値と長期間の平均値を比較する
        * 最初の方は短期の計測値の平均値が低く、パーティクルは配置されない
        * 数回計測をしてパーティクルが真のロボットの位置に近づいた場合短期長期の平均値はともに上昇したまにランダムパーティクルが配置される
        * 誘拐された時は長期間の計測値の平均値が早く下がり、ランダムパーティクルが多く配置される

* どのような確率分布に従ってパーティクルを生成すべきか？  
    * 姿勢の空間前位置に渡る一様分布からランダムにパーティクルを生成し、その時の観測から重みを計算する
    * 計測の分布にしたがって直接パーティクルを生成する
        * ランドマーク検出モデル


### KLDサンプリング

粒子が広範囲に分布したらパーティクルの数を増やす  
* 誘拐されたあと、AugmentMCLによってランダムなパーティクルを広範囲に加える
    * パーティクルの分布が広がるとKLDサンプリングによってパーティクルの数を増やす
* 誘拐から回復したらAugmentMCLによるランダム粒子の生成が経る
    * パーティクルの分布が集中すると粒子数を減少させる

### サブスクライブトピック

* scan:レーザセンサデータ
* tf
* initialpose:パーティクルフィルタを(再び)初期化する平均及び共分散
* map:use_map_topicパラメータを設定するとレーザセンサの位置を指定するマップを取得する

### パブリッシュトピック

 * amcl_pose:マップ内のロボットの推定位置と共分散
* particlecoud:推定位置のセット、フィルタによって維持している
* tf:変換をodomからmapに公開する

### サービス


* global_localization:大域的な自己位置推定を開始する
* request_nomotion_update:更新を手動実行し、更新されたパーティクルを公開する
* set_map:手動で新しいマップとポーズを設定する

### 呼び出されるサービス

* static_map:amclはこのサービスを利用して、LiDARによる自己位置推定に使用されるマップを取得する

### パラメータ

#### フィルター全体パラメータ

* **min_particles**(int):パーティクルの最小許容数、デフォルトは100
* **max_particles**(int):パーティクルの最大許容数、デフォルトは5000
* **kld_err**(double):真の分布と推定分布の最大誤差、デフォルトは0.01
* **kld_z**(double):(1-p)の上位標準正規分位数、pは推定分布の誤差がkld_errより小さい確率。デフォルトは0.99
* **update_min_d**(double):フィルタの更新をするまでの並進移動の最低距離。デフォルトは0.2[m]
* **update_min_a**(double):フィルタの更新をするまでの回転移動の最低距離。デフォルトはπ/6[rad]
* **resample_interval**(int):リサンプリングする間隔、デフォルトは2
* **transform_tolerance**(double):TFのタイムスタンプと現在時刻のズレの許容値
    * TFが以降も有効であることを示すために、パブリッシュしたTFを遅らせる時間。デフォルトは0.1[sed]
* **recovery_aplha_slow**(double):低速平均重みフィルターの指数減衰率、適切な値は0.001。デフォルトは0.0で無効
    * ランダムな姿勢を追加して回復するタイミングを決定する際に使用する
* **recovery_aplha_fast**(double):高速平均重みフィルターの指数減衰率、適切な値は0.01。デフォルトは0.0で無効
    * ランダムな姿勢を追加して回復するタイミングを決定する際に使用する
* **initial_pose_x**(double):初期ポーズ平均、ガウス分布でフィルター初期化の際に使用。デフォルトは0[m]
* **initial_pose_y**(double):初期ポーズ平均、ガウス分布でフィルター初期化の際に使用。デフォルトは0[m]
* **initial_pose_a**(double):初期ポーズ平均、ガウス分布でフィルター初期化の際に使用。デフォルトは0[rad]
* **initial_cov_xx**(double):初期ポーズ共分散 ( x * x )、ガウス分布でフィルター初期化の際に使用。デフォルトは 0.5 * 0.5[m]
    * 値が大きくなるほどパーティクルの分布、角度が広がる
* **initial_cov_yy**(double):初期ポーズ共分散 ( y * y )、ガウス分布でフィルター初期化の際に使用。デフォルトは 0.5 * 0.5[m]
* **initial_cov_aa**(double):初期ポーズ共分散 ( yaw * yaw )、ガウス分布でフィルター初期化の際に使用。デフォルトは π/12 * π/12[rad]
* **gui_publish_rate**(double):Rvizで視覚化のためにスキャンとパスが公開される最大頻度、デフォルトは-0.1[Hz]で無効
* **save_pose_rate**(double):変数initial_**にパラメータサーバへの最後の推定ポーズと共分散を保存する最大頻度、デフォルトは0.5[hz]
    * 保存されたポーズはフィルタ初期化に使用される、-1.0で無効
* **use_map_topic**(bool):trueでマップを受信するサービス呼び出しを行わずにマップトピックをサブスクライブする、デフォルトはfalse

#### LiDAR関連パラメータ

* **laser_min_range**(double):計算に使用する値の最小距離、デフォルトは-1.0で無効
* **laser_max_range**(double):計算に使用する値の使用する最大距離、デフォルト-1.0で無効
* **laser_max_beams**(double):フィルタ更新に使うレーザの本数、デフォルトは30

```
以下、z_hit,z_rand,z_max,z_shordは足して1になる用に設定する
尤度場を使用するときはz_hitとz_randのみ使用する
```

* **laser_z_hit**(double):モデルのz_hit部分の混合重み、デフォルトは0.1
    * 地図に記載されている障害物を正しく計測した確率
* **laser_z_short**(double):モデルのz_short部分の混合重み、デフォルトは0.1
    * 人などの想定外の障害物により地図に記載されている障害物より短い値を計測した確率
* **laser_z_max**(double):モデルのz_max部分の混合重み、デフォルトは0.05
    * 計測失敗により計測可能範囲の最大値をとる確率
* **laser_z_rand**(double):モデルのz_rand部分の混合重み、デフォルトは0.05
    * 原因不明のランダムな値を計測した確率
* **laser_sigma_hit**(double):正しい値を計測した時のガウスモデルの標準偏差、デフォルトは0.2[m]
* **laser_lambda_short**(double):短い値を計測した時の指数関数減衰パラメータ、デフォルトは0.1
* **laser_likelihood_max_dist**(double):尤度場モデルで使用するためにマップ上で障害物の膨張を行う最大距離、デフォルトは2.0[m]
    * p.153をみる
* **laser_model_type**(string):使用するモデルの選択、デフォルトはlikelihood_field
    * **beam**:ビームモデル
    * **likelihood_field**:尤度場モデル
    * **likelihood_field_prob**:
    * 尤度フィールドと同じだが有効な場合はビームスキップ機能が組み込まれている？

#### 走行距離計モデルのパラメータ

* **odom_model_type**(string):使用するモデル、デフォルトはdiff
    * diff:sample_motion_model_odomertryアルゴリズムを使用する
        * 確率論ロボティクスのp123参考
        * alpha1~4のロボットの固有の４つのノイズを使用する
    * omni:全方位に動くロボットのモデル
        * alpha1~4に加えて5番目のパラメータも使用する。観測された進行方向に関して垂直に回転せず移動する
    * diff-corrected:バグFIXした。パラメータをより小さく設定する必要がある
    * omni-corrected:バグFIXした
* **odom_alpha1**(double):ロボットの運動の回転成分から走行距離計の回転推測値に予想されるノイズ、デフォルトは0.2
* **odom_alpha2**(double):ロボットの動きの並進成分からオドメトリの回転推定値に予想されるノイズ、デフォルトは0.2
* **odom_alpha3**(double):ロボットの運動の並進成分からオドメトリの並進推定値に予想されるノイズ、デフォルトは0.2
* **odom_alpha4**(double):ロボットの運動の回転成分から走行距離計の並進推定値に予想されるノイズ、デフォルトは0.2
* **odom_alpha5**(double):変換関連のノイズパラメータでomniの場合のみ、デフォルトは0.2
* **odom_frame_id**(string):オドメトリに使用するフレーム名、デフォルトはodom
* **base_frame_id**(string):ロボットのベースリンクのフレーム名、デフォルトはbase_link
* **global_frame_id**(string):自己位置推定によってパブリッシュされるフレーム名、デフォルトはmap
* **tf_broadcast**(bool):falseでグローバルフレームとオドメトリフレームの変換を公開しない、デフォルトはtrue

Navigation1.16より前のバージョンではomni、omni-correctedでパラメータ1と4の値が入れ替わるバグがあるので注意

### 参考記事

* 確率ロボティクス(p.143)
    * z_hit: センサの計測値がおおよそ正しい、ガウス分布
    * z_short: 人が通りすぎる等でセンサの計測値が実際より小さい、指数分布
    * z_max: 計測失敗で最大値を返す、一様分布
    * z_rand: 適当な値を返す、一様分布
* [ROSのナビゲーションamclについて理解を深めてみる](https://sy-base.com/myrobotics/ros/ros-amcl/)
    * パラメータの説明とLiDARの計測モデルの話
* [QIITA](https://qiita.com/MoriKen/items/dfb6eb168649873589f0)
    * 尤度場モデルを理解するには混乱するので他の部分

## LiDARの計測モデル

* [参考記事](https://sy-base.com/myrobotics/ros/lidar-measurement-model/)



## 確率ロボティクス

センサから得た不確かなデータから確率を用いてロボットの位置を推定する方法について記述された本

### 概要単語

* **状態**:ロボットと環境の将来に影響するすべての局面
    * **動的状態**:人のように時間経過とともに変化する状態
    * **静的状態**:建物の壁のように動かない場合
    * ロボットの姿勢、速度、センサが正しく動作しているかも状態
* **姿勢**:グローバル座標系に対するロボットの位置、向き
    * 移動ロボットは変数６つで、```xyz, roll pitch yaw```
    * 平面を移動する場合の変数は3つ```x y yaw```
* **環境計測データ**:カメラ、測域センサの情報
* **制御データ**:状態の変化に関するデータ、速度の情報
* **信念**:環境の状態に関するロボットの内部知識、ロボットの主観
    * ベイズフィルタによって計算可能
        * 再帰的であるため、時刻tの信念は時刻t-1から計算される
        * 実際的なアルゴリズムではないため近似が適用される
* **マルコフ性**:現在の状態が既知ならば、過去や未来のデータが独立していることを要求する仮定
* **ノンパラメトリックフィルタ**:状態空間中の各領域と対応付ける数値で事後信念を近似する


### MCLで計算量を少なくする方法

* **モデルプレキャッシング**: 固定された地図に対して計測モデルの計算を事前計算しておくことで計算量を少なくする
* **センササブサンプリング**:計測値の一部だけ計測モデルを評価する、例えば360個のレーザから8個のみ使用する、何秒に１回に評価するなど
* **遅延動作更新**:ロボットの動作更新をロボットの制御や計測の頻度よりも少ない頻度で適用
* **選択的更新**：一部の格子セルしか更新をしない

### パーティクルフィルタ

パーティクルフィルタとは、ノンパラメトリックなベイズフィルタの実装方法の一つ  
事後信念から状態をランダムにサンプリングした標本の集合で事後信念を表現する  
汎用性が高く実装が簡単
* **パーティクル**:事後確率分布の標本


#### 流れ

時刻tにおける状態の仮説```x_t^[m]```を時刻t-1における状態```x_(t-1)^[m]```と制御```u_t```から生成する  
各パーティクルに対して計測```z_t```を得る確率である**重要度係数**を計算する  
リサンプリングを行う

#### メモ

* リサンプリング
    * 例えばロボットが移動せず、センサも持たない場合、リサンプリングを行うことで  
徐々にパーティクルが1箇所に集まる場合がある  
よって、リサンプリングを行うタイミングを選ぶ方法が取られる
* **パーティクルの喪失問題**
    * パーティクルの数が多くても、真の状態からパーティクルがなくなる問題
* 格子のサイズは15cmがよい(p.218)
* パーティクルの数は次の制御値```u_t```と計測値```z_t```が到着する前に計算終了するまでに設定する


### 計測モデル

センサの値をモデルに組み込む  
条件付き確率分布で表す
```p(z_t|x_t, m)```
* z_t:センサの値
* x_t:ロボットの姿勢
* m  :地図

#### 尤度場

* AMCLで用いるデフォルトの計測モデル
* ２次元座標での距離を用いて確率分布をモデル化する
* センサスキャンの端点を地図のグローバル座標空間中に投影する
    * ロボットの位置、センサがロボットのどの位置から発せれているか、センサの向きを知る必要がある
* 最大距離が計測されたら無視する
* ```センサの値 = z_hit * 正しい値が計測される確率分布　+ z_rand * ランダムな値が計測される確率分布 + z_max * 最大値が計測される確率分布 ```
* 欠点
    * 計算値を短くする人などの移動体をモデル化していない
    * 壁を透視できるように扱っている
    * 地図の不確かさが考慮されていないので未探索問題をクリアできない




























